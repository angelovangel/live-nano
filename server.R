# server part of the live-nano-type app
# logic - the file test.tsv (generated by jsa) is read periodically
# and the results are plotted as bubble and table

  streamfile <- "stream.tsv"
  # generate a dataframe with zeros, to write on exit to stream.tsv
  columns <- c("time", "step", "reads", "bases", "species", "prob", "err", "tAligned", "sAligned")
  emptystream <- setNames(data.frame(matrix(ncol = 9, nrow = 1, 0)), columns)
  fileData <- reactiveFileReader(500, NULL, streamfile, fread)
  

function(input, output, session) {
  
  options(shiny.launch.browser = TRUE)

   session$onSessionEnded(function() {
     fwrite(emptystream, file = "stream.tsv")
     #stopApp() # comment out on deploy
   })
  
  # fileData <- reactiveFileReader(500, session, streamfile, fread)
 
  # OBSERVERS
  observeEvent(input$simulate, {
    shinyjs::disable("simulate")
    # system call here, so that I can use wait=F
    p <- system2("./simulateST.R", 
                 args = c("-f" ,"testdata/HMW_Zymo.tsv",
                          "-o", "stream.tsv",
                          "-s", "1"), 
                 wait = FALSE)
    
  })
  
  
  # reactive vals for storing total and mapped reads
  readsData <- reactiveValues(mapped = 0, total = 0)
  
  filteredData <- reactive({
    
    # validate(need(
    #   file.exists(streamfile), "error"
    # ))
    #req(file.exists(streamfile), )
    
    fileData() %>% 
      dplyr::mutate(Abundance_t = sAligned/readsData$total, Abundance_m = sAligned/readsData$mapped) %>%
      dplyr::filter(prob > input$probfilter & Abundance_m > (input$abundfilter/100))
  })
  
  
  
  output$rawtable <- renderTable({
    filteredData()
  })
  
  output$mreads <- renderValueBox({
    readsData$mapped <- fileData()[1,8] %>% as.numeric()
    
    valueBox(
      value = prettyNum(readsData$mapped, big.mark = ","),
      subtitle = ifelse(
        readsData$mapped == 0, # handle case at start, when the df is nulls only
        "NA",
        paste("Mapped reads:", scales::percent(readsData$mapped/readsData$total), "of total")
        ),
      icon = icon("dna")
    )
  })
  output$treads <- renderValueBox({
    readsData$total <- fileData()[1,3] %>% as.numeric()
    
    valueBox(
      value = prettyNum(readsData$total, big.mark = ","),
      subtitle = HTML("<b>Total reads</b> | <b>Step:</b> ", 
                       last(fileData()$step),
                       " | <b>Timestamp:</b>",
                       as.character(parse_date_time(last(fileData()$time), orders = "a b! d! HMS Y")) 
                       ),
      icon = icon("dna")
    )
  })
  
  output$abundanceTable <- renderFormattable({
    if (nrow(filteredData()) == 0)
      return()
    
    df <- filteredData() %>%
      dplyr::filter(step == max(step)) %>%
      dplyr::select(species, prob, sAligned, Abundance_m) %>%
      dplyr::mutate(Abundance_m = formattable::percent(Abundance_m)) %>%
      dplyr::arrange(desc(sAligned)) %>%
      dplyr::mutate(prob = round(prob, 2)) %>%
      # just the top 20?
      head(20)
    
    formattable(df, list(sAligned = formattable::color_bar("lightgreen"),
                         Abundance_m = formattable::color_bar("lightgreen"),
                         prob = formattable::color_bar("lightgreen")))
    
  })
  
  output$abundancePlot <- renderBubbles({
    if (nrow(filteredData()) == 0)
      return()
    df <- filteredData() %>%
      dplyr::filter(step == max(step)) %>%
      dplyr::arrange(desc(Abundance_m)) %>%
      # assign colors according to prob
      dplyr::mutate(prob_color = scales::col_numeric("YlGn", domain = c(0,1))(prob)) %>%
     # just the top 20?
      head(20)
    
    bubbles(value = df$sAligned, 
            label = df$species, 
            key = df$species, 
            color = df$prob_color,
            tooltip = paste("Prob = ", df$prob, "\n", "Reads = ", df$sAligned))
    
  })
  
  
}